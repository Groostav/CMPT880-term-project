Randoop

Randoop is an automated unit test generation tool for Java classes that using a randomized algorithm, starts by invoking sequences of method/constructors for the classes under test. Then, it saves the results and try to re-use them in order to invoke more complex sequences that uses different sets of method calls. This approach has led developers to reveal unknown issues even in extensively used libraries such as Oracle JDK.

Our purpose of implementing Randoop is to automatically generate tests (regression tests in this case) in order to feed intruder and, therefore, find concurrency issues with little to no human intervention, and at the same time, improving code coverage.

Experiments

We have implented runner.sh to ensamble Randoop => Porter => Intruder, and evaluated several test cases and benchmark libraries. Our experiments were performed on an Kubuntu 15.10 dual-core 2Ghz virtual machine with 4GB RAM.

The table 1 shows a comparison between the results obtained using hand-crafted test cases and the results obtained using our automated framework to obtain the test cases. The values shown in each cell (a,b,c) represent:

a: the intruder execution time in milliseconds.
b: the total number of multithreaded tests generated by Intruder
c: the amount of atomicity violations found

We used the functional libraries cases provided with the Intruder application in order to obtain a baseline. Our method was consistent with Intruder’s original results where no atomicity violations were found in the baseline tests: Intruder-functional-test-1, 3, 5, 9, 10, 11, 12 and 13. However, I higher execution time was observed due to the highly more complex test case generated by randoop on these cases.

Due to the nature of intruder-funcitonal-test-2 i.e. only one method implemented, not receiving any arguments and not calling any function in the method, Randoop was not able to generate any test cases. 

We also compared the functionality on two of the benchmark provided by Intruder. In both cases, after running intruder using the test driver generated by porter, we found a smaller subset of atomicity violations on the tested libraries, but also a shorter execution time. 

Conclusion

From this project, we motivate the need of automatically generated test cases, especially feedback-directed random test generation in this experiment, to detect atomicity violations using INTRUDER in thread-safe libraries and components. We designed an approach that is less time consuming than the actual case in which the sequential test cases are generated manually. We synthesized a tool call PORTER and tested several small programs with and without bugs and two real world libraries using it. Most of the cases, our approach finds the underlying concurrency bug. However, our approach generated more duplicates than the one described in INTRUDER because of several calls to same function. To conclude we can say that the approach described in the current paper will be more useful in case when the tester doesn’t know the underlying implementation and details about the library to be tested.
